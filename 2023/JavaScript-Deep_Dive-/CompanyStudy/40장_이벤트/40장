**40장 이벤트 **
40.1 이벤트 드리븐 프로그래밍

이벤트 드리븐(Event-Driven) 프로그래밍은 프로그램의 동작을 이벤트에 의해 트리거하는 프로그래밍 패러다임입니다. 
이벤트 드리븐 프로그래밍은 사용자 입력, 외부 시스템과의 상호작용, 시간에 따른 변화 등과 같은 이벤트에 반응하여 동작하는 방식으로 프로그램을 구성합니다.

전통적인 프로그래밍 방식에서는 일련의 순차적인 코드가 실행되지만, 
이벤트 드리븐 프로그래밍에서는 프로그램이 대기하다가 특정 이벤트가 발생하면 이벤트 핸들러(이벤트 리스너)가 실행되어 이벤트에 대한 처리를 수행합니다. 
이벤트 드리븐 프로그래밍은 비동기적인 방식으로 동작하며, 여러 이벤트가 동시에 발생할 수 있는 환경에서 유용하게 사용됩니다.

일반적으로 이벤트 드리븐 프로그래밍은 이벤트 루프(Event Loop)라는 메커니즘을 사용하여 이벤트 처리를 관리합니다. 
이벤트 루프는 이벤트 큐(Event Queue)에 등록된 이벤트를 하나씩 가져와 실행하고, 필요한 경우 콜백 함수나 이벤트 핸들러를 호출합니다. 
이벤트 루프를 통해 다중 이벤트 처리, 비동기 작업, 동시성 제어 등을 효율적으로 처리할 수 있습니다.

JavaScript는 이벤트 드리븐 프로그래밍을 지원하는 언어로, 웹 애플리케이션에서 주로 사용됩니다. 
웹 페이지에서 발생하는 이벤트(버튼 클릭, 마우스 이동, 키보드 입력 등)에 대한 처리를 JavaScript를 통해 구현할 수 있습니다. 
JavaScript에서는 이벤트 리스너를 등록하고 이벤트에 대한 동작을 정의하는 방식으로 이벤트 드리븐 프로그래밍을 구현합니다.

이벤트 드리븐 프로그래밍은 사용자와의 상호작용, 비동기적인 데이터 처리, 
실시간 업데이트 등 다양한 상황에서 유용하게 활용됩니다. 
이벤트에 따라 프로그램의 동작을 유연하게 제어할 수 있으며, 
사용자 경험을 향상시키는 데에도 도움이 됩니다.

40.2 이벤트 타입

이벤트 타입(Event Type)은 어떤 종류의 이벤트가 발생했는지를 식별하는 데 사용되는 값입니다. 
이벤트 타입은 이벤트의 성격과 의미를 나타내며, 해당 이벤트에 대한 처리 방식을 결정하는 데에 중요한 역할을 합니다.

각각의 이벤트 타입은 고유한 이름을 가지며, 이벤트가 발생할 때 해당 타입의 이름을 사용하여 이벤트를 식별합니다. 
프로그래밍 환경에 따라 다양한 이벤트 타입이 정의되어 있으며, 예를 들면 다음과 같은 일반적인 이벤트 타입이 있습니다:

Click 이벤트: 마우스 버튼을 클릭했을 때 발생하는 이벤트입니다. 대표적인 Click 이벤트 타입으로는 "click"이 있습니다.

1. Key 이벤트: 키보드의 키 입력에 대한 이벤트입니다. Key 이벤트는 키를 눌렀을 때, 뗐을 때, 
누르고 있는 동안 등 다양한 상황에서 발생할 수 있습니다. 
일반적인 Key 이벤트 타입으로는 "keydown", "keyup", "keypress" 등이 있습니다.

2. Mouse 이벤트: 마우스 관련 동작에 대한 이벤트입니다. Mouse 이벤트는 마우스의 움직임, 
버튼 클릭, 스크롤 등 다양한 상황에서 발생할 수 있습니다. 
일반적인 Mouse 이벤트 타입으로는 "mousemove", "mousedown", "mouseup", "mouseover", "mouseout" 등이 있습니다.

3. Form 이벤트: 웹 폼 요소에서 발생하는 이벤트입니다. Form 이벤트는 폼을 제출(submit)할 때, 
입력 필드에 포커스가 이동했을 때, 값이 변경되었을 때 등 다양한 상황에서 발생할 수 있습니다. 
일반적인 Form 이벤트 타입으로는 "submit", "focus", "blur", "change" 등이 있습니다.

4. Window 이벤트: 브라우저 창과 관련된 이벤트입니다. Window 이벤트는 창의 크기가 변경되었을 때, 
스크롤이 발생했을 때, 창이 닫힐 때 등 다양한 상황에서 발생할 수 있습니다. 
일반적인 Window 이벤트 타입으로는 "resize", "scroll", "unload" 등이 있습니다.

40.3 이벤트 핸들러 등록

이벤트 핸들러 등록은 특정 이벤트가 발생했을 때 실행될 함수를 지정하는 과정을 말합니다. 
이벤트 핸들러를 등록하면 해당 이벤트가 발생했을 때 원하는 동작을 수행할 수 있습니다.

다음과 같은 단계로 이루어집니다

1. 이벤트 대상 선택: 이벤트 핸들러를 등록할 HTML 요소를 선택합니다. 
이 요소는 이벤트가 발생하는 대상이 됩니다. 대상 요소는 id, 클래스, 
태그 이름 등을 사용하여 선택할 수 있습니다.

2. 이벤트 핸들러 함수 작성: 이벤트가 발생했을 때 실행될 함수를 작성합니다. 
이 함수는 이벤트가 발생했을 때 실행될 코드를 포함합니다. 일반적으로 JavaScript 함수로 작성되며, 
매개변수로 이벤트 객체를 전달받을 수도 있습니다.

3. 이벤트 핸들러 등록: 이벤트 대상 요소에 대해 이벤트 핸들러를 등록합니다. 
대부분의 프로그래밍 환경에서는 이벤트 핸들러 등록을 위한 메서드 또는 속성을 제공합니다. 
예를 들어, 웹 개발에서는 addEventListener 메서드를 사용하여 이벤트 핸들러를 등록할 수 있습니다.

4. 이벤트 핸들러 실행: 이벤트가 발생하면 등록된 이벤트 핸들러 함수가 실행됩니다. 
이벤트 핸들러 함수는 이벤트 객체를 사용하여 이벤트 정보를 확인하고, 원하는 동작을 수행합니다.

(01)
위의 코드에서 #myButton id를 가진 요소를 선택하여 클릭 이벤트 핸들러를 등록하고 있습니다. 
클릭 이벤트가 발생하면 handleClick 함수가 실행되어 "버튼이 클릭되었습니다!"라는 메시지가 출력됩니다.

이벤트 핸들러 등록은 웹 개발을 비롯한 다양한 프로그래밍 분야에서 중요한 개념입니다. 
이를 통해 사용자의 상호작용에 따라 동적인 동작을 구현하거나 원하는 이벤트를 감지하여 특정 동작을 수행할 수 있습니다.

40.4 이벤트 핸들러 제거

이벤트 핸들러를 제거하는 것은 이벤트가 발생했을 때 실행되는 함수와 이벤트 대상 요소의 연결을 해제하는 과정입니다. 
이벤트 핸들러를 제거하면 해당 이벤트가 발생했을 때 더 이상 연결된 함수가 실행되지 않습니다.

일반적으로 이벤트 핸들러 제거는 등록된 이벤트 핸들러를 등록할 때 사용한 메서드 또는 속성을 사용하여 수행합니다. 
이벤트 핸들러를 등록할 때 사용한 메서드와 반대의 작업을 수행하여 이벤트 핸들러를 제거할 수 있습니다.

예를 들어, addEventListener 메서드로 등록한 이벤트 핸들러를 제거하는 방법은 removeEventListener 메서드를 사용하는 것입니다. 
removeEventListener 메서드는 이벤트 대상 요소에서 등록된 특정 이벤트 핸들러를 제거합니다.
(02)
위의 코드에서 addEventListener 메서드로 등록한 클릭 이벤트 핸들러를 removeEventListener 메서드로 제거하고 있습니다. 
이제 해당 버튼을 클릭해도 handleClick 함수는 실행되지 않습니다.

이벤트 핸들러를 제거하는 것은 필요한 경우에 사용하여 메모리 누수를 방지하거나 불필요한 동작을 제어하는 데 도움이 됩니다. 
이벤트 핸들러가 더 이상 필요하지 않을 때는 항상 제거하는 것이 좋습니다.

40.5 이벤트 객체

이벤트 객체는 이벤트가 발생했을 때 해당 이벤트에 대한 정보를 담고 있는 JavaScript 객체입니다. 
이벤트 핸들러 함수의 매개변수로 전달되며, 이벤트에 관련된 다양한 속성과 메서드를 제공합니다.

일반적으로 이벤트 객체는 이벤트 핸들러 함수의 첫 번째 매개변수로 사용됩니다. 
예를 들어, 클릭 이벤트의 핸들러 함수에서는 event 또는 e와 같은 이름으로 이벤트 객체를 참조할 수 있습니다.

이벤트 객체는 다양한 속성을 가지고 있으며, 이벤트 유형에 따라 사용할 수 있는 속성들이 다를 수 있습니다. 
일반적으로 사용되는 속성은 다음과 같습니다:

- type: 이벤트의 유형을 나타내는 문자열입니다. 예를 들어, 클릭 이벤트는 'click', 키보드 이벤트는 'keydown', 마우스 이벤트는 'mousemove'과 같은 값을 가질 수 있습니다.
- target: 이벤트가 발생한 요소를 나타내는 객체입니다. 이벤트가 발생한 요소를 기준으로 추가적인 동작을 수행할 수 있습니다.
- currentTarget: 이벤트 핸들러가 현재 실행 중인 요소를 나타내는 객체입니다. 이벤트 버블링이나 캡처링 중에 이벤트 핸들러가 실행되는 요소를 참조할 때 사용할 수 있습니다.
- preventDefault(): 이벤트의 기본 동작을 취소할 수 있는 메서드입니다. 이를 호출하면 일부 이벤트의 기본 동작(예: 폼 제출, 링크 이동)이 방지됩니다.
- stopPropagation(): 이벤트의 전파를 중단시키는 메서드입니다. 이를 호출하면 이벤트가 상위 요소로 전파되는 것을 막을 수 있습니다.

위의 속성 외에도 다양한 이벤트 유형에 따라 해당 이벤트에 관련된 다양한 정보를 제공하는 속성들이 있을 수 있습니다. 
이벤트 객체를 사용하여 이벤트에 대한 세부 정보를 확인하고 필요에 따라 제어할 수 있습니다.


40.6 이벤트 전파

이벤트 전파(Event Propagation)는 HTML 요소들 사이에서 발생한 이벤트가 상위 요소로 전달되는 과정을 의미합니다. 
이벤트 전파는 이벤트 버블링(Event Bubbling)과 이벤트 캡처링(Event Capturing) 두 가지 방식으로 이루어집니다.

이벤트 버블링(Event Bubbling): 이벤트가 발생한 요소에서 시작하여 상위 요소로 순차적으로 전파되는 방식입니다.
즉, 가장 깊은 요소에서부터 시작하여 계층 구조 상위 요소들로 이벤트가 전파됩니다. 이벤트 버블링은 일반적으로 발생하며, 
대부분의 이벤트가 이 방식으로 전파됩니다. 상위 요소에서 이벤트를 처리하고자 할 때 유용합니다.

이벤트 캡처링(Event Capturing): 이벤트가 발생한 요소에서 시작하여 상위 요소로 역순으로 전파되는 방식입니다. 
즉, 가장 상위 요소에서부터 시작하여 계층 구조 하위 요소들로 이벤트가 전파됩니다. 
이벤트 캡처링은 이벤트 버블링의 반대 개념으로, 현재는 잘 사용되지 않습니다.

이벤트 전파는 기본적으로 이벤트가 발생한 요소에서 시작하여 부모 요소, 
그 다음 부모 요소의 부모 요소로 전파되는 식으로 계속 상위로 전파됩니다. 
이벤트 전파는 이벤트 핸들러를 등록한 요소 이외의 상위 요소에서도 이벤트를 감지하고 처리할 수 있도록 합니다.

이벤트 전파를 중단하고자 할 때는 stopPropagation() 메서드를 사용합니다. 
이를 호출하면 이벤트는 현재 요소에서 더 이상 상위 요소로 전파되지 않습니다.
이를 통해 이벤트 전파를 중단시키고 특정 요소에서 이벤트를 처리할 수 있습니다.

이벤트 전파는 DOM의 계층 구조를 활용하여 이벤트 처리를 유연하게 할 수 있도록 도와줍니다. 
이를 이해하고 적절히 활용하면 복잡한 이벤트 처리 로직을 구현할 수 있습니다.

40.7 이벤트 위임

이벤트 위임(Event Delegation)은 다수의 하위 요소에 대한 이벤트 처리를 상위 요소 하나에게 위임하는 방법입니다. 
이벤트 위임을 사용하면 각각의 하위 요소에 대해 별도의 이벤트 핸들러를 등록하는 대신 상위 요소에서 하나의 이벤트 핸들러를 사용하여 처리할 수 있습니다.

주요한 이점

1. 메모리 사용 감소: 하위 요소마다 이벤트 핸들러를 등록하는 대신, 상위 요소에 하나의 이벤트 핸들러만 등록하므로 메모리 사용이 줄어듭니다.

2. 동적 요소 처리: 동적으로 추가되거나 제거되는 하위 요소에 대해서도 자동으로 이벤트 처리를 수행할 수 있습니다.

3. 코드 관리 용이성: 이벤트 핸들러를 하나의 공통된 상위 요소에 등록하므로 코드 관리가 용이해집니다.

이벤트 위임은 주로 상위 요소에 이벤트 핸들러를 등록하고, 이
벤트가 발생한 요소를 이벤트 객체의 target 속성을 통해 식별하여 처리합니다. 이렇게 하면 상위 요소에서 이벤트를 감지하고, 
발생한 요소를 식별하여 처리할 수 있습니다.

예를 들어, 여러 개의 버튼이 있는 경우 각 버튼에 대해 개별적인 
이벤트 핸들러를 등록하는 대신 상위 요소에 하나의 클릭 이벤트 핸들러를 등록하고, 
이벤트가 발생한 버튼을 event.target을 통해 식별하여 처리할 수 있습니다. 
이렇게 하면 버튼이 추가되거나 삭제되어도 상위 요소에서 자동으로 이벤트 처리가 이루어집니다.

이벤트 위임은 복잡한 DOM 구조나 동적인 요소에 유용하며, 
코드의 성능과 유지 보수성을 향상시킬 수 있는 패턴입니다.

40.8 DOM요소의 기본 동작 조작

DOM 요소의 기본 동작을 조작하는 것은 DOM 이벤트를 활용하여 요소의 기본 동작을 변경하거나 막는 것을 의미합니다. 
이는 일부 기본 동작을 사용자 정의 동작으로 대체하거나 기본 동작을 방지하여 원하는 동작을 구현하는 데 유용합니다.

기본 동작 조작 방법

1. 이벤트 취소: 이벤트 핸들러 내에서 event.preventDefault()를 호출하여 
해당 이벤트의 기본 동작을 취소할 수 있습니다. 예를 들어, 
링크를 클릭할 때 페이지 이동을 막고, 버튼을 클릭할 때 폼 전송을 막을 수 있습니다.

2. 이벤트 전파 중단: 이벤트 핸들러 내에서 event.stopPropagation()을 호출하여 
이벤트의 전파를 중단할 수 있습니다. 이는 상위 요소로 이벤트가 전파되는 것을 
막아 하위 요소에만 이벤트가 처리되도록 할 수 있습니다.

3. 기본 동작 변경: 일부 DOM 요소는 특정 이벤트에 대해 기본 동작을 가지고 있습니다. 
이를 변경하기 위해 이벤트 핸들러 내에서 적절한 작업을 수행하여 기본 동작을 원하는 동작으로 대체할 수 있습니다. 
예를 들어, 폼 제출 이벤트에서 폼 데이터를 수집하고 서버로 전송하는 등의 작업을 수행할 수 있습니다.

4. 이벤트 위임: 앞서 설명한 이벤트 위임을 사용하여 기본 동작을 조작할 수도 있습니다. 
상위 요소에 이벤트 핸들러를 등록하고, 이벤트가 발생한 요소를 식별하여 기본 동작을 변경하거나 막을 수 있습니다.

이러한 방법을 사용하여 DOM 요소의 기본 동작을 조작하면 원하는 동작을 구현할 수 있습니다. 
다양한 DOM 이벤트와 메서드를 활용하여 기본 동작을 조작하는 방법을 익히면 
상호작용적인 웹 애플리케이션을 구현하는 데 도움이 됩니다.

40.9 이벤트 핸들러 내부의 this

이벤트 핸들러 내부의 this는 현재 실행 중인 이벤트 핸들러가 연결된 요소를 참조하는 특별한 키워드입니다. 
이벤트 핸들러 함수가 호출될 때, this는 해당 이벤트를 발생시킨 DOM 요소를 가리킵니다.

this를 사용하여 이벤트 핸들러 내에서 현재 요소에 대한 작업을 수행할 수 있습니다. 
예를 들어, 버튼 클릭 이벤트의 핸들러 함수에서 this를 사용하여 클릭된 버튼의 속성을 읽거나 변경할 수 있습니다.

일반적으로, this는 해당 이벤트 핸들러가 연결된 DOM 요소를 참조하게 됩니다. 
그러나 화살표 함수를 사용하여 이벤트 핸들러를 정의한 경우에는 Lexical this 바인딩이 
발생하여 this가 다른 값을 가리킬 수 있습니다. 화살표 함수를 사용하는 경우에는 주의해야 합니다.

또한, 이벤트 핸들러 내부에서 this를 다른 변수에 할당하여 나중에 사용할 수도 있습니다. 
이를 통해 이벤트 핸들러 외부에서도 현재 요소를 참조할 수 있습니다.

요약하면, 이벤트 핸들러 내부의 this는 해당 이벤트를 발생시킨 DOM 요소를 가리키는 특별한 키워드입니다. 
이를 활용하여 현재 요소에 대한 작업을 수행하거나 다른 변수에 할당하여 외부에서 참조할 수 있습니다.

40.11 커스텀 이벤트

커스텀 이벤트는 개발자가 직접 정의한 이벤트입니다. 
일반적으로 브라우저에서 제공하는 기본 이벤트 외에도 독자적인 이벤트를 만들어야 할 때 사용됩니다. 
이를 통해 컴포넌트 간 통신이나 사용자 정의 동작을 구현할 수 있습니다.

커스텀 이벤트를 생성하려면 CustomEvent 생성자를 사용하거나 document.createEvent 메서드를 사용할 수 있습니다. 
생성된 커스텀 이벤트는 dispatchEvent를 사용하여 DOM 요소에 보내지며, 해당 요소에서 이벤트를 수신하는 이벤트 핸들러가 호출됩니다.

(03)
위 예시에서는 'myEvent'라는 이름의 커스텀 이벤트를 생성하고, 
bubbles 옵션을 true로 설정하여 이벤트가 이벤트 캡처링 및 버블링 단계를 거치도록 합니다. 
detail 속성을 사용하여 추가 데이터를 전달할 수 있습니다. 그런 다음, document.dispatchEvent를 사용하여 이벤트를 보냅니다.

커스텀 이벤트를 수신하기 위해 addEventListener를 사용하여 이벤트 핸들러를 등록합니다. 
이벤트 핸들러 함수 내에서 event.detail을 통해 전달된 데이터에 접근할 수 있습니다.

커스텀 이벤트는 개발자가 필요에 따라 독립적으로 정의하고 사용할 수 있으므로 유연한 이벤트 기반 프로그래밍을 구현하는 데 활용됩니다.

